<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EHSA Visualization Tool</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin="anonymous" />
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" 
          rel="stylesheet"
          integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"
          crossorigin="anonymous">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"
            crossorigin="anonymous"></script>
    
    <!-- JSON Formatter -->
    <script src="https://cdn.jsdelivr.net/npm/json-formatter-js@2.3.4/dist/json-formatter.umd.min.js"
            crossorigin="anonymous"></script>
    
    <style>
        body {
            padding: 0;
            margin: 0;
            font-family: Arial, sans-serif;
        }
        
        #map {
            height: 70vh;
            width: 100%;
        }
        
        .info-panel {
            max-height: 30vh;
            overflow-y: auto;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        
        .time-series-chart {
            height: 300px;
            width: 100%;
        }
        
        .legend {
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }
        
        .legend-item {
            margin-bottom: 5px;
        }
        
        .legend-color {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border: 1px solid #ccc;
        }
        
        .tooltip-custom {
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            max-width: 300px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .neighbors-highlight {
            stroke: #ff0000;
            stroke-width: 3;
            fill-opacity: 0.3;
        }
        
        .selected-feature {
            stroke: #0000ff;
            stroke-width: 3;
            fill-opacity: 0.5;
        }
        
        .btn-inspect {
            margin-top: 10px;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="row mt-3">
            <div class="col-12">
                <h1 class="text-center">EHSA Visualization Tool</h1>
            </div>
        </div>
        
        <div class="row mt-3">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5>Upload EHSA Results (CSV)</h5>
                    </div>
                    <div class="card-body">
                        <input type="file" id="csvFileInput" class="form-control" accept=".csv">
                        <small class="text-muted">Upload the CSV file containing EHSA results with GeoJSON geometry column.</small>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row mt-3">
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header">
                        <h5>Map</h5>
                    </div>
                    <div class="card-body p-0">
                        <div id="map"></div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-4">
                <div class="card">
                    <div class="card-header">
                        <h5>Information Panel</h5>
                    </div>
                    <div class="card-body info-panel" id="infoPanel">
                        <p>Click on a region to see details.</p>
                    </div>
                </div>
                
                <div class="card mt-3">
                    <div class="card-header">
                        <h5>Actions</h5>
                    </div>
                    <div class="card-body">
                        <button id="inspectGeometryBtn" class="btn btn-primary" disabled>Inspect Time Series</button>
                        <!-- 
                        TODO: Show Neighbors button is temporarily hidden
                        The geographic neighbor detection logic is implemented and working,
                        but needs refinement for grid data visualization.
                        Remove style="display: none;" below to re-enable the button.
                        -->
                        <button id="showNeighborsBtn" class="btn btn-secondary" disabled style="display: none;">Show Neighbors</button>
                        <button id="resetMapBtn" class="btn btn-outline-danger">Reset Map</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row mt-3">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5>Time Series Analysis</h5>
                    </div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="timeSeriesChart"></canvas>
                        </div>
                        <div id="timeSeriesInfo" class="mt-3"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin="anonymous"></script>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
            crossorigin="anonymous"></script>
    
    <script>
        // Global variables
        let map;
        let geojsonLayer;
        let selectedFeature = null;
        let neighborFeatures = [];
        let timeSeriesChart = null;
        
        // Security: Escape HTML to prevent XSS attacks
        function escapeHtml(unsafe) {
            if (unsafe == null || unsafe === undefined) return '';
            return String(unsafe)
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
        
        // Atualizar as cores das classificações conforme o gabarito fornecido
        const classificationColors = {
            'no pattern detected': 'lightgray',
            'new hotspot': 'mediumturquoise',
            'new coldspot': '#87CEEB',
            'sporadic hotspot': 'lightsalmon',
            'sporadic coldspot': '#B0E0E6',
            'consecutive hotspot': 'orangered',
            'consecutive coldspot': '#4682B4',
            'persistent hotspot': 'saddlebrown',
            'persistent coldspot': '#000080',
            'intensifying hotspot': 'purple',
            'intensifying coldspot': '#483D8B',
            'diminishing hotspot': 'orange',
            'diminishing coldspot': '#1E90FF',
            'historical hotspot': '#8B4513',
            'historical coldspot': '#00008B',
            'oscilating hotspot': '#FF8C00',
            'oscilating coldspot': '#0000CD',
        };
        
        // Initialize the map
        function initMap() {
            map = L.map('map').setView([0, 0], 2);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            
            createLegend();
        }
        
        // Create map legend
        function createLegend() {
            const legend = L.control({position: 'bottomright'});
            
            legend.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML = '<h6>Classification</h6>';
                
                for (const classification in classificationColors) {
                    div.innerHTML += `
                        <div class="legend-item">
                            <span class="legend-color" style="background-color: ${classificationColors[classification]}"></span>
                            ${classification}
                        </div>
                    `;
                }
                
                return div;
            };
            
            legend.addTo(map);
        }
        
        // Style function for GeoJSON features
        function styleFeature(feature) {
            const classification = feature.properties.classification;
            return {
                fillColor: classificationColors[classification] || '#CCCCCC',
                weight: 1,
                opacity: 1,
                color: '#666',
                fillOpacity: 0.7
            };
        }
        
        // Handle CSV file upload
        document.getElementById('csvFileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }
            
            console.log('File selected:', file.name);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                console.log('File loaded successfully');
                const csvData = e.target.result;
                processCSVData(csvData);
            };
            reader.onerror = function(e) {
                console.error('Error reading file:', e);
                alert('Error reading file. Please try again.');
            };
            reader.readAsText(file);
        });
        
        // Process CSV data and convert to GeoJSON
        function processCSVData(csvData) {
            console.log('Processing CSV data...');
            const lines = csvData.split('\n');
            const headers = lines[0].split(',');
            
            console.log('CSV Headers:', headers);
            
            // Find indices for required columns
            const geometryIndex = headers.findIndex(h => h.toLowerCase().includes('geometry'));
            const classificationIndex = headers.findIndex(h => h.toLowerCase().includes('classification') && !h.toLowerCase().includes('details'));
            
            // More flexible region identifier detection
            let idIndex = -1;
            
            // First, try common region identifier patterns
            const regionIdentifierPatterns = [
                'geoquadhash', 'geohash', 'id', 'region', 'name_muni', 'municipality', 
                'area_id', 'zone', 'district', 'code', 'key', 'identifier'
            ];
            
            for (const pattern of regionIdentifierPatterns) {
                idIndex = headers.findIndex(h => 
                    !h.toLowerCase().includes('classification') && 
                    !h.toLowerCase().includes('geometry') &&
                    h.toLowerCase().includes(pattern)
                );
                if (idIndex !== -1) break;
            }
            
            // If still not found, use the first column that's not geometry or classification
            if (idIndex === -1) {
                idIndex = headers.findIndex((h, index) => 
                    index !== geometryIndex && 
                    index !== classificationIndex &&
                    !h.toLowerCase().includes('details') &&
                    !h.toLowerCase().includes('summary') &&
                    !h.toLowerCase().includes('data') &&
                    !h.toLowerCase().includes('tau') &&
                    !h.toLowerCase().includes('p_value')
                );
            }
            
            console.log('Column indices:', {
                geometry: geometryIndex,
                classification: classificationIndex,  
                id: idIndex,
                idColumnName: idIndex !== -1 ? headers[idIndex] : 'Not found'
            });
            
            if (geometryIndex === -1) {
                const errorMsg = 'CSV must contain a geometry column';
                console.error(errorMsg);
                alert(errorMsg);
                return;
            }
            
            if (classificationIndex === -1) {
                const errorMsg = 'CSV must contain a classification column';
                console.error(errorMsg);
                alert(errorMsg);
                return;
            }
            
            if (idIndex === -1) {
                const errorMsg = `CSV must contain a region identifier column. Available columns: ${headers.join(', ')}`;
                console.error(errorMsg);
                alert(errorMsg);
                return;
            }
            
            // Convert CSV to GeoJSON
            const features = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const columns = parseCSVLine(lines[i]);
                if (columns.length !== headers.length) continue;
                
                let geometry;
                try {
                    // Try to parse geometry (GeoJSON format)
                    const geometryStr = columns[geometryIndex].trim();
                    console.log('Raw geometry string:', geometryStr);
                    
                    // Check if it's a Python dictionary string format
                    if (geometryStr.startsWith('{') && geometryStr.includes("'type'")) {
                        // Convert Python dict string to valid JSON
                        const jsonStr = geometryStr
                            .replace(/'/g, '"')  // Replace single quotes with double quotes
                            .replace(/\(/g, '[')  // Replace parentheses with brackets
                            .replace(/\)/g, ']'); // Replace parentheses with brackets
                        
                        try {
                            geometry = JSON.parse(jsonStr);
                        } catch (e) {
                            console.error('Failed to parse converted JSON:', e);
                            // Try to fix any remaining issues with the coordinates
                            const fixedStr = jsonStr.replace(/,\s*\]/g, ']'); // Remove trailing commas
                            geometry = JSON.parse(fixedStr);
                        }
                    }
                    // Check if it's already a GeoJSON object
                    else if (geometryStr.startsWith('{')) {
                        geometry = JSON.parse(geometryStr);
                    } 
                    // Check if it's a WKT format
                    else if (geometryStr.startsWith('POLYGON') || geometryStr.startsWith('MULTIPOLYGON')) {
                        // Convert WKT to GeoJSON
                        const coords = geometryStr
                            .replace('POLYGON ((', '')
                            .replace('))', '')
                            .split(',')
                            .map(coord => coord.trim().split(' ').map(Number));
                        
                        geometry = {
                            type: 'Polygon',
                            coordinates: [coords]
                        };
                    }
                    // Check if it's a simple coordinate string
                    else if (geometryStr.includes(',')) {
                        const coords = geometryStr
                            .split(',')
                            .map(coord => coord.trim().split(' ').map(Number));
                        
                        geometry = {
                            type: 'Polygon',
                            coordinates: [coords]
                        };
                    }
                    
                    console.log('Parsed geometry:', geometry);
                } catch (e) {
                    console.error('Failed to parse geometry:', e);
                    console.error('Problematic geometry string:', columns[geometryIndex]);
                    continue;
                }
                
                // Create properties object from all columns
                const properties = {};
                
                // Security: Block dangerous prototype pollution keys
                const dangerousKeys = ['__proto__', 'constructor', 'prototype'];
                
                headers.forEach((header, index) => {
                    if (index !== geometryIndex) {
                        // Skip dangerous keys that can pollute object prototypes
                        if (dangerousKeys.includes(header)) {
                            console.warn(`Skipping dangerous property key: ${header}`);
                            return;
                        }
                        
                        const value = columns[index];
                        
                        // Handle complex data columns that should be parsed as JSON
                        const complexColumns = ['location_data', 'classification_details', 'mann_kendall_details', 'spatial_context_summary'];
                        if (complexColumns.includes(header)) {
                            try {
                                properties[header] = JSON.parse(value);
                            } catch (e) {
                                console.log(`Failed to parse ${header} as JSON, trying Python parsing:`, e);
                                properties[header] = parsePythonString(value);
                            }
                        } else {
                            // For simple columns, try JSON parsing first, then use as-is
                            try {
                                const parsed = JSON.parse(value);
                                // Only use parsed result if it's not a string (avoid double-parsing simple strings)
                                properties[header] = (typeof parsed === 'string' && parsed === value) ? value : parsed;
                            } catch (e) {
                                // If not JSON, use as is
                                properties[header] = value;
                            }
                        }
                    }
                });
                
                features.push({
                    type: 'Feature',
                    geometry: geometry,
                    properties: properties
                });
            }
            
            const geojson = {
                type: 'FeatureCollection',
                features: features
            };
            
            loadGeoJSON(geojson);
        }
        
        // Parse CSV line handling quoted values with commas
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current);
            return result;
        }
        
        // Load GeoJSON data onto the map
        function loadGeoJSON(geojson) {
            // Remove existing layer if present
            if (geojsonLayer) {
                map.removeLayer(geojsonLayer);
            }
            
            // Add new GeoJSON layer
            geojsonLayer = L.geoJSON(geojson, {
                style: styleFeature,
                onEachFeature: onEachFeature
            }).addTo(map);
            
            // Fit map to GeoJSON bounds
            map.fitBounds(geojsonLayer.getBounds());
            
            // Enable buttons
            document.getElementById('resetMapBtn').disabled = false;
        }
        
        // Define actions for each feature
        function onEachFeature(feature, layer) {
            // Add popup with basic info
            const regionId = getRegionId(feature.properties);
            const classification = feature.properties.classification;
            
            layer.bindTooltip(`
                <div class="tooltip-custom">
                    <h6>Region: ${escapeHtml(regionId)}</h6>
                    <p>Classification: ${escapeHtml(classification)}</p>
                </div>
            `, {
                sticky: true,
                direction: 'top'
            });
            
            // Add click handler
            layer.on({
                click: function(e) {
                    if (selectedFeature) {
                        geojsonLayer.resetStyle(selectedFeature);
                    }
                    
                    layer.setStyle({
                        weight: 3,
                        color: '#0000ff',
                        fillOpacity: 0.7
                    });
                    
                    selectedFeature = layer;
                    
                    // Enable buttons
                    document.getElementById('inspectGeometryBtn').disabled = false;
                    document.getElementById('showNeighborsBtn').disabled = false;
                    
                    // Show feature details
                    showFeatureDetails(feature);
                    
                    L.DomEvent.stopPropagation(e);
                }
            });
        }
        
        // Get region identifier from properties
        function getRegionId(properties) {
            // Extended list of patterns to match region identifiers
            const regionIdentifierPatterns = [
                'geoquadhash', 'geohash_6', 'geohash_5', 'geohash_4', 'geohash', 
                'id', 'region', 'name_muni', 'municipality', 'area_id', 'zone', 
                'district', 'code', 'key', 'identifier'
            ];
            
            // First pass: try exact matches with patterns
            for (const pattern of regionIdentifierPatterns) {
                for (const key in properties) {
                    if (key.toLowerCase().includes(pattern)) {
                        return properties[key];
                    }
                }
            }
            
            // Second pass: look for properties that are not metadata/complex objects
            const excludePatterns = ['classification', 'details', 'summary', 'data', 'geometry', 'tau', 'p_value'];
            for (const key in properties) {
                const keyLower = key.toLowerCase();
                const isExcluded = excludePatterns.some(pattern => keyLower.includes(pattern));
                if (!isExcluded && (typeof properties[key] === 'string' || typeof properties[key] === 'number')) {
                    return properties[key];
                }
            }
            
            // Final fallback: use the first non-excluded property
            const keys = Object.keys(properties);
            for (const key of keys) {
                const keyLower = key.toLowerCase();
                const isExcluded = excludePatterns.some(pattern => keyLower.includes(pattern));
                if (!isExcluded) {
                    return properties[key];
                }
            }
            
            return 'Unknown';
        }
        
        // Helper to parse Python-like object strings or JSON strings into valid JSON
        function parsePythonString(pyStr) {
            if (typeof pyStr !== 'string') {
                return pyStr;
            }
            
            // First, remove outer quotes if they exist (from CSV formatting)
            if (pyStr.startsWith('"') && pyStr.endsWith('"')) {
                pyStr = pyStr.substring(1, pyStr.length - 1);
            }
            
            // Also remove escaped quotes that are artifacts of CSV encoding
            pyStr = pyStr.replace(/\\"/g, '"');
            
            try {
                // Try parsing as JSON first (for data exported from our new format)
                return JSON.parse(pyStr);
            } catch (jsonError) {
                console.log("Not valid JSON, trying Python-style parsing...", jsonError);
                
                try {
                    // Handle datetime.date(YYYY, M, D) -> "YYYY-MM-DD"
                    let jsonStr = pyStr.replace(/datetime\.date\((\d+),\s*(\d+),\s*(\d+)\)/g, (match, year, month, day) => {
                        // Pad month and day with leading zeros if necessary
                        const fMonth = String(month).padStart(2, '0');
                        const fDay = String(day).padStart(2, '0');
                        return `"${year}-${fMonth}-${fDay}"`;
                    });

                    // Standard replacements for Python literals to JSON
                    jsonStr = jsonStr.replace(/'/g, '"')
                                     .replace(/\bTrue\b/g, 'true')
                                     .replace(/\bFalse\b/g, 'false')
                                     .replace(/\bNone\b/g, 'null')
                                     .replace(/\bnan\b/g, 'null')
                                     .replace(/\bNaN\b/g, 'null');
                    
                    return JSON.parse(jsonStr);
                } catch (pythonError) {
                    console.error("Failed to parse both JSON and Python-like string:", pyStr);
                    console.error("JSON error:", jsonError);
                    console.error("Python parsing error:", pythonError);
                    // Return original string on failure to avoid breaking the UI completely
                    return pyStr;
                }
            }
        }

        // Helper: pretty print any JS object/array, but show location_data as a table
        function prettyPrintData(data, indent = 0, key = null) {
            if (key === 'location_data') {
                const parsedData = parsePythonString(data);

                if (Array.isArray(parsedData) && parsedData.length > 0 && typeof parsedData[0] === 'object') {
                    // Build an HTML table
                    let cols = Object.keys(parsedData[0]);
                    let html = '<div style="overflow-x:auto;"><table border="1" cellpadding="4" cellspacing="0" style="border-collapse:collapse;font-size:12px;width:100%"><thead><tr>';
                    cols.forEach(col => { html += `<th>${escapeHtml(col)}</th>`; });
                    html += '</tr></thead><tbody>';
                    parsedData.forEach(row => {
                        html += '<tr>';
                        cols.forEach(col => { html += `<td>${escapeHtml(row[col] !== null && row[col] !== undefined ? row[col] : '')}</td>`; });
                        html += '</tr>';
                    });
                    html += '</tbody></table></div>';
                    return html;
                }
            }
            // Fallback for other data types
            let html = '';
            const pad = '&nbsp;'.repeat(indent * 4);
            if (Array.isArray(data)) {
                html += '<ul style="margin:0 0 0 1em;padding:0">';
                data.forEach(item => {
                    html += '<li>' + prettyPrintData(item, indent + 1) + '</li>';
                });
                html += '</ul>';
            } else if (typeof data === 'object' && data !== null) {
                html += '<ul style="margin:0 0 0 1em;padding:0">';
                for (const k in data) {
                    html += `<li>${pad}<strong>${escapeHtml(k)}:</strong> ${prettyPrintData(data[k], indent + 1, k)}</li>`;
                }
                html += '</ul>';
            } else {
                 // Try to parse if it's a python string before showing it
                const parsedData = parsePythonString(data);
                if (typeof parsedData === 'object' && parsedData !== null) {
                    return prettyPrintData(parsedData, indent + 1);
                }
                html += pad + escapeHtml(String(data));
            }
            return html;
        }

        // Show feature details in info panel
        function showFeatureDetails(feature) {
            const infoPanel = document.getElementById('infoPanel');
            const regionId = getRegionId(feature.properties);
            const classification = feature.properties.classification;
            
            let html = `
                <h6>Region: ${escapeHtml(regionId)}</h6>
                <p><strong>Classification:</strong> ${escapeHtml(classification)}</p>
                <p><strong>Mann-Kendall Tau:</strong> ${escapeHtml(feature.properties.tau)}</p>
                <p><strong>p-value:</strong> ${escapeHtml(feature.properties.p_value)}</p>
            `;
            
            // Show all details recursively
            const fields = [
                ['Classification Details', 'classification_details'],
                ['Mann-Kendall Details', 'mann_kendall_details'],
                ['Spatial Context Summary', 'spatial_context_summary'],
                ['Location Data', 'location_data']
            ];
            fields.forEach(([label, key]) => {
                if (feature.properties[key]) {
                    let value = feature.properties[key];
                    // The value should already be parsed from the CSV loading, but handle string case
                    if (typeof value === 'string') {
                        value = parsePythonString(value);
                    }
                    html += `<h6>${label}</h6>`;
                    html += prettyPrintData(value, 0, key);
                }
            });
            
            infoPanel.innerHTML = html;
            
            // Enable buttons
            document.getElementById('inspectGeometryBtn').disabled = false;
            document.getElementById('showNeighborsBtn').disabled = false;
        }
        
        // Show neighbors of selected feature
        document.getElementById('showNeighborsBtn').addEventListener('click', function() {
            if (!selectedFeature) return;
            
            const feature = selectedFeature.feature;
            console.log('Selected feature properties:', feature.properties);
            
            // Try to parse spatial_context_summary with more robust parsing
            let spatialContext;
            try {
                if (typeof feature.properties.spatial_context_summary === 'string') {
                    // Handle Python-style dictionary strings
                    let contextStr = feature.properties.spatial_context_summary;
                    console.log('Raw spatial_context_summary:', contextStr);
                    
                    // More robust parsing for Python-style strings
                    contextStr = contextStr
                        .replace(/'/g, '"')                    // Replace single quotes with double quotes
                        .replace(/\bTrue\b/g, 'true')          // Replace Python True with JSON true
                        .replace(/\bFalse\b/g, 'false')        // Replace Python False with JSON false
                        .replace(/\bNone\b/g, 'null');         // Replace Python None with JSON null
                    
                    spatialContext = JSON.parse(contextStr);
                } else {
                    spatialContext = feature.properties.spatial_context_summary;
                }
            } catch (e) {
                console.error('Failed to parse spatial_context_summary:', e);
                console.log('Attempting alternative parsing...');
                
                // Try alternative parsing method
                try {
                    spatialContext = parsePythonString(feature.properties.spatial_context_summary);
                } catch (e2) {
                    console.error('Alternative parsing also failed:', e2);
                    alert('Unable to parse neighbor information for this region');
                    return;
                }
            }
            
            console.log('Parsed spatial context:', spatialContext);
            
            if (!spatialContext || !spatialContext.neighbors_config) {
                alert('No neighbor information available for this region');
                return;
            }
            
            console.log('Neighbors config:', spatialContext.neighbors_config);
            
            // Handle neighbors_config - it might be a string or array
            let neighbors;
            if (typeof spatialContext.neighbors_config === 'string') {
                neighbors = spatialContext.neighbors_config.split(',').map(n => n.trim());
            } else if (Array.isArray(spatialContext.neighbors_config)) {
                neighbors = spatialContext.neighbors_config;
            } else {
                console.error('Unexpected neighbors_config format:', spatialContext.neighbors_config);
                alert('Unable to process neighbor configuration');
                return;
            }
            
            console.log('Processed neighbors list:', neighbors);
            
            // Reset previous highlights
            if (neighborFeatures.length > 0) {
                neighborFeatures.forEach(f => {
                    geojsonLayer.resetStyle(f);
                    if (f._iconBlinkInterval) {
                        clearInterval(f._iconBlinkInterval);
                        f._iconBlinkInterval = null;
                    }
                });
                neighborFeatures = [];
            }
            
            // Highlight neighbors with green and blinking effect
            let foundNeighbors = 0;
            geojsonLayer.eachLayer(layer => {
                const properties = layer.feature.properties;
                const regionId = String(getRegionId(properties)).trim(); // Convert to string and trim
                
                console.log('Checking layer with regionId:', regionId);
                
                // Check if this regionId matches any neighbor (with string comparison)
                const isNeighbor = neighbors.some(neighbor => String(neighbor).trim() === regionId);
                
                if (isNeighbor) {
                    console.log('Found neighbor:', regionId);
                    foundNeighbors++;
                    
                    let blink = true;
                    let baseStyle = {
                        fillColor: '#90ee90', // lightgreen
                        fillOpacity: 0.7,
                        weight: 2,
                        color: '#228B22' // forestgreen
                    };
                    layer.setStyle(baseStyle);
                    // Piscar: alterna opacidade
                    let interval = setInterval(() => {
                        blink = !blink;
                        layer.setStyle({
                            ...baseStyle,
                            fillOpacity: blink ? 0.7 : 0.2
                        });
                    }, 500);
                    layer._iconBlinkInterval = interval;
                    neighborFeatures.push(layer);
                }
            });
            
            console.log(`Found ${foundNeighbors} neighbors out of ${neighbors.length} expected`);
            
            // If no neighbors found by ID matching, try geographic proximity for grid data
            if (foundNeighbors === 0 && neighbors.length > 0) {
                console.log('No neighbors found by ID, trying geographic proximity...');
                
                const selectedCoords = selectedFeature.getLatLng();
                let proximityNeighbors = [];
                
                geojsonLayer.eachLayer(layer => {
                    if (layer === selectedFeature) return; // Skip self
                    
                    const layerCoords = layer.getLatLng();
                    const distance = selectedCoords.distanceTo(layerCoords);
                    
                    proximityNeighbors.push({
                        layer: layer,
                        distance: distance,
                        regionId: getRegionId(layer.feature.properties)
                    });
                });
                
                // Sort by distance and take closest 8 (typical for grid)
                proximityNeighbors.sort((a, b) => a.distance - b.distance);
                const closestNeighbors = proximityNeighbors.slice(0, 8);
                
                console.log(`Found ${closestNeighbors.length} geographic neighbors`);
                
                // Highlight the closest neighbors
                closestNeighbors.forEach(neighbor => {
                    let blink = true;
                    let baseStyle = {
                        fillColor: '#90ee90', // lightgreen
                        fillOpacity: 0.7,
                        weight: 2,
                        color: '#228B22' // forestgreen
                    };
                    neighbor.layer.setStyle(baseStyle);
                    
                    let interval = setInterval(() => {
                        blink = !blink;
                        neighbor.layer.setStyle({
                            ...baseStyle,
                            fillOpacity: blink ? 0.7 : 0.2
                        });
                    }, 500);
                    neighbor.layer._iconBlinkInterval = interval;
                    neighborFeatures.push(neighbor.layer);
                });
                
                foundNeighbors = closestNeighbors.length;
            } else if (neighbors.length === 0) {
                alert('This region has no neighbors.');
            }
        });
        
        // Inspect time series of selected geometry
        document.getElementById('inspectGeometryBtn').addEventListener('click', function() {
            if (!selectedFeature) return;
            
            const feature = selectedFeature.feature;
            let locationData = feature.properties.location_data;
            
            if (!locationData) {
                alert('No time series data available for this region');
                return;
            }

            console.log('Raw location_data:', locationData);
            console.log('Type of location_data:', typeof locationData);

            // Parse the location data
            const data = parsePythonString(locationData);
            
            console.log('Parsed location_data:', data);
            console.log('Is array:', Array.isArray(data));

            if (!Array.isArray(data)) {
                console.error('Expected array but got:', typeof data, data);
                alert(`Time series data is not in expected array format. Got: ${typeof data}. Please check the console for more details.`);
                return;
            }
            
            if (data.length === 0) {
                alert('Time series data is empty for this region');
                return;
            }
            
            // Validate data structure
            const firstItem = data[0];
            if (!firstItem || typeof firstItem !== 'object') {
                console.error('Expected array of objects but got:', firstItem);
                alert('Time series data structure is invalid. Expected array of objects.');
                return;
            }
            
            // Check for required fields
            const requiredFields = ['time_period', 'value', 'is_significant'];
            const missingFields = requiredFields.filter(field => !(field in firstItem));
            if (missingFields.length > 0) {
                console.error('Missing required fields:', missingFields);
                alert(`Time series data is missing required fields: ${missingFields.join(', ')}`);
                return;
            }
            // Sort by time period
            data.sort((a, b) => {
                if (a.time_period < b.time_period) return -1;
                if (a.time_period > b.time_period) return 1;
                return 0;
            });
            const timeLabels = data.map(d => d.time_period);
            const giValues = data.map(d => d.value);
            const significantPoints = data.map(d => d.is_significant ? d.value : null);
            // Destroy previous chart if exists
            if (timeSeriesChart) {
                timeSeriesChart.destroy();
            }
            // Create new chart
            const ctx = document.getElementById('timeSeriesChart').getContext('2d');
            timeSeriesChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'Gi* Statistic',
                            data: giValues,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: 'rgba(75, 192, 192, 0.2)',
                            borderWidth: 2,
                            tension: 0.1
                        },
                        {
                            label: 'Significant Points',
                            data: significantPoints,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 0,
                            pointRadius: 10, // maior
                            pointStyle: 'circle',
                            showLine: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Time Series for Region: ${escapeHtml(getRegionId(feature.properties))}`
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const dataIndex = context.dataIndex;
                                    const isSignificant = data[dataIndex].is_significant;
                                    return [`Significant: ${isSignificant ? 'Yes' : 'No'}`];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Gi* Value'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time Period'
                            }
                        }
                    }
                }
            });
            // Display additional time series info
            const timeSeriesInfo = document.getElementById('timeSeriesInfo');
            const classification = feature.properties.classification;
            const tau = feature.properties.tau;
            const pValue = feature.properties.p_value;
            timeSeriesInfo.innerHTML = `
                <h5>Time Series Analysis for Region: ${escapeHtml(getRegionId(feature.properties))}</h5>
                <p><strong>Classification:</strong> ${escapeHtml(classification)}</p>
                <p><strong>Mann-Kendall Tau:</strong> ${escapeHtml(tau)} (p-value: ${escapeHtml(pValue)})</p>
                <p><strong>Number of Time Periods:</strong> ${escapeHtml(data.length)}</p>
                <p><strong>Significant Periods:</strong> ${escapeHtml(data.filter(d => d.is_significant).length)}</p>
            `;
        });
        
        // Reset map button
        document.getElementById('resetMapBtn').addEventListener('click', function() {
            // Remove selection and highlights
            if (selectedFeature) {
                geojsonLayer.resetStyle(selectedFeature.layer);
                selectedFeature = null;
            }
            if (neighborFeatures.length > 0) {
                neighborFeatures.forEach(f => {
                    geojsonLayer.resetStyle(f);
                    if (f._iconBlinkInterval) {
                        clearInterval(f._iconBlinkInterval);
                        f._iconBlinkInterval = null;
                    }
                });
                neighborFeatures = [];
            }
            document.getElementById('inspectGeometryBtn').disabled = true;
            document.getElementById('showNeighborsBtn').disabled = true;
            document.getElementById('infoPanel').innerHTML = '<p>Click on a region to see details.</p>';
            if (timeSeriesChart) {
                timeSeriesChart.destroy();
                timeSeriesChart = null;
            }
            document.getElementById('timeSeriesInfo').innerHTML = '';
        });
        
        // Initialize the map when the page loads
        window.onload = function() {
            initMap();
        };
    </script>
</body>
</html> 